import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

class RobustErgonomicGovernor:
    def __init__(self, seed=42):
        np.random.seed(seed) # For reproducibility
        # Biomechanical Constraints (Krstic, 2024)
        self.L_max = 100.0        # System Integrity Barrier (% RULA Equivalent)
        self.recovery_max = 0.12  # Max physiological recovery rate
        self.noise_std = 0.35     # IMU Drift Standard Deviation (Filippeschi, 2017)

        # Adaptive Triggering Parameters (Wang et al., 2023)
        self.sigma = 0.4          # Triggering sensitivity
        self.eta_init = 1.0       # Initial stability buffer
        self.xi_hat = 10.0        # Last transmitted state reference

        # State History
        self.events = []
        self.u_current = 0.0      # Current Swarm Assistance Magnitude

    def get_intensity(self, t):
        """Simulates time-varying work demand (I) with a Stress Phase (200-400s)."""
        if 200 <= t <= 400:
            return 2.5  # High-intensity stress test phase
        return 1.2      # Baseline operation phase

    def system_dynamics(self, t, state):
        xi, eta = state

        # 1. Non-linear Ergonomic Load Dynamics
        I_t = self.get_intensity(t)
        accumulation = I_t / (1.0 + 3.0 * self.u_current)

        # Non-linear dissipation: Recovery efficiency drops as xi increases
        dissipation = self.recovery_max * xi * (1.0 - (xi / (1.1 * self.L_max)))

        # Stochastic component (Sensor Noise / Human micro-motions)
        d_noise = np.random.normal(0, self.noise_std)
        d_xi = accumulation - dissipation + d_noise

        # 2. Girard Dynamic Triggering Variable (Girard, 2015)
        error = np.abs(xi - self.xi_hat)
        threshold = self.sigma * np.abs(xi) + 0.1
        # Buffer eta decreases when error > threshold
        d_eta = -0.6 * eta + (threshold - error)

        return [d_xi, d_eta]

    def solve(self, duration=600):
        t_eval = np.linspace(0, duration, 1000)
        t_current = 0
        y_current = [10.0, self.eta_init] # Initial load 10, buffer 1

        results_t, results_y, results_u = [], [], []

        while t_current < duration:
            t_end = min(t_current + 1.0, duration)
            sol = solve_ivp(self.system_dynamics, (t_current, t_end), y_current,
                            t_eval=np.linspace(t_current, t_end, 10), rtol=1e-5)

            xi_now, eta_now = sol.y[0, -1], sol.y[1, -1]

            # TRIGGERING LOGIC (Wang's Adaptive Event-Triggering)
            if eta_now <= 0.05 or xi_now >= 0.9 * self.L_max:
                self.events.append(sol.t[-1])
                self.xi_hat = xi_now
                
                # REFINED: MMFSA Niche Selection Simulation
                # The swarm identifies 3 distinct supportive configurations (Niches)
                possible_niches = np.array([0.4, 0.7, 0.9]) 
                # Optimization: Choose niche that best counters the current load xi
                target_ratio = min(xi_now / self.L_max, 0.9)
                self.u_current = possible_niches[np.argmin(np.abs(possible_niches - target_ratio))]
                
                y_current = [xi_now, self.eta_init] # Reset eta buffer
            else:
                y_current = [xi_now, eta_now]

            results_t.extend(sol.t)
            results_y.extend(sol.y.T)
            results_u.extend([self.u_current] * len(sol.t))
            t_current = t_end

        return np.array(results_t), np.array(results_y), np.array(results_u)

gov = RobustErgonomicGovernor()
time, states, control = gov.solve()

plt.figure(figsize=(12, 10))

# Top: Ergonomic Load xi(t)
plt.subplot(3, 1, 1)
plt.plot(time, states[:, 0], color='blue', label=r'Ergonomic Load ξ(t)')
plt.axhline(y=gov.L_max, color='red', linestyle='--', label=r'Integrity Barrier Lmax')
plt.fill_between(time, 90, 100, color='red', alpha=0.1, label='Critical Zone')
plt.scatter(gov.events, [states[np.searchsorted(time, e), 0] for e in gov.events],
            color='orange', s=30, label='AETM Triggers (Niche Shift)')
plt.title('Dynamic Integrity Governance: Stochastic Stress Test (200-400s)')
plt.ylabel(r'Magnitude (\%)')
plt.legend(loc='upper right')
plt.grid(True, alpha=0.3)

# Middle: Girard Variable eta(t)
plt.subplot(3, 1, 2)
plt.plot(time, states[:, 1], color='green', label=r'Stability Buffer η(t)')
plt.axhline(y=0.05, color='orange', linestyle=':', label='Trigger Threshold')
plt.ylabel('Buffer Level')
plt.legend()
plt.grid(True, alpha=0.3)

# Bottom: Swarm Intervention Magnitude u(t) (Niche States)
plt.subplot(3, 1, 3)
plt.step(time, control, color='purple', where='post', label=r'Swarm Niche Assistance u(t)')
plt.ylabel('Niche Assistance Level')
plt.xlabel('Time (seconds)')
plt.legend()
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
