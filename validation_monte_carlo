import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
import pandas as pd
import os

# 1. CALIBRATED RESEARCH PARAMETERS (Aligned with Table 2 [cite: 150])

NUM_EXPERIMENTS = 1000  # Statistical robustness for Cohenâ€™s d calculation [cite: 13]
TIME_STEP = 0.01        # 100Hz frequency (Slade et al., 2022) [cite: 57, 107]
TOTAL_TIME = 100        # Simulation duration per run
L_MAX = 1.0             # Normalized Integrity Barrier [cite: 68, 150]

# Physiological torque limits (Nm) for 7-DOF arm (Winter, 2009) [cite: 58, 150]
TAU_MAX = np.array([50.0, 50.0, 40.0, 30.0, 20.0, 15.0, 10.0]) 

# AETM & Girard Parameters (Borgers & Heemels / Wang et al.) [cite: 86, 97, 150]
SIGMA_0 = 0.15          # Initial triggering coefficient (Calibrated) [cite: 150]
MU = 2.5                # Aggressiveness Factor (mu) [cite: 93, 150]
LAMBDA_GIRARD = 0.6     # Buffer Decay Rate (lambda) [cite: 102, 150]
THETA_GIRARD = 0.8      # Triggering Gain (theta) [cite: 103, 150]

# DIG ODE Parameters (Safari et al., 2025) [cite: 74, 82, 150]
KAPPA = 0.15            # Scaling Coefficient (s^-1) [cite: 74, 150]
D_MAX = 0.25            # Peak Recovery Constant (Calibrated for stability) [cite: 82]

# 2. BIOMECHANICAL DYNAMICS MODEL [cite: 53, 69]

class HumanArm7DOF:
    """
    Simulates 7-DOF kinematic effort and stochastic IMU jitter d(t)[cite: 125, 188].
    """
    def __init__(self, seed=None):
        if seed is not None: np.random.seed(seed)
        self.q = np.zeros(7)
        
    def calculate_torque(self, task_intensity):
        # Stochastic jitter representing IMU noise (Slade et al., 2022) [cite: 57, 107, 299]
        noise = np.random.normal(0, 0.35, 7) 
        # Dynamic torque based on task intensity and joint configuration [cite: 70, 318]
        return task_intensity * (np.sin(self.q) + 1.2) + noise

# 3. GOVERNOR ODE ENGINE [cite: 76, 293]

def dig_system_dynamics(xi, t, tau, kappa, d_max):
    """
    Implements the non-linear evolution of ergonomic load xi(t)[cite: 76, 317].
    """
    # Eq (3): Accumulation Rate A(t) [cite: 73, 320]
    acc = kappa * np.sqrt(np.sum((tau / TAU_MAX)**2))
    
    # Eq (5): Rectified Dissipation D(xi) to prevent divergence 
    # This safety operator ensures recovery stays non-negative.
    recovery_potential = (1 - (xi / (1.1 * L_MAX)))
    diss = d_max * xi * max(0, recovery_potential) 
    
    return acc - diss


# 4. MONTE CARLO EXPERIMENT [cite: 160, 182]

def run_governor_monte_carlo():
    all_runs = []
    
    if not os.path.exists('experiment_results'):
        os.makedirs('experiment_results')

    for i in range(NUM_EXPERIMENTS):
        if (i+1) % 100 == 0: print(f"Processing Run {i+1}/{NUM_EXPERIMENTS}...")
        
        arm = HumanArm7DOF(seed=42+i) # Seeded for exact reproducibility [cite: 150, 295]
        xi = 0.1       # Initial Ergonomic Load xi(0) [cite: 150, 307]
        eta = 1.0      # Initial Girard Buffer eta(0) [cite: 150, 306]
        xi_last = xi   # Last transmitted reference [cite: 90, 307]
        
        triggers = 0
        xi_log = []
        time_pts = np.arange(0, TOTAL_TIME, TIME_STEP)
        
        for t in time_pts:
            # Task Intensity Phase (Simulating Stress Period 20s-60s) [cite: 185, 312]
            intensity = 1.8 if 20 < t < 60 else 1.2
            tau = arm.calculate_torque(intensity)
            
            # Step ODE: State evolution [cite: 76, 334]
            xi_step = odeint(dig_system_dynamics, xi, [t, t+TIME_STEP], args=(tau, KAPPA, D_MAX))[-1][0]
            xi = max(0, xi_step) # Ensure non-negative load
            
            # AETM Logic & Girard Buffer [cite: 89, 99, 327]
            error = abs(xi_last - xi)
            sigma_t = SIGMA_0 * np.exp(-MU * xi) # Adaptive threshold [cite: 92, 329]
            
            # Buffer dynamics d_eta (Girard framework) [cite: 99, 333]
            d_eta = -LAMBDA_GIRARD * eta + THETA_GIRARD * (sigma_t - error)
            eta += d_eta * TIME_STEP
            
            # Triggering Condition (eta <= 0) [cite: 106, 346]
            if eta <= 0:
                triggers += 1
                xi_last = xi  # Update transmitted state [cite: 348]
                eta = 1.0     # Reset Girard Buffer [cite: 354]
            
            xi_log.append(xi)
            
        all_runs.append({
            'run': i,
            'updates': triggers,
            'peak_load': max(xi_log),
            'efficiency': (1 - (triggers / len(time_pts))) * 100
        })

    return pd.DataFrame(all_runs)

# 5. DATA REPORTING & AUDIT [cite: 161, 196]

if __name__ == "__main__":
    results_df = run_governor_monte_carlo()
    
    # Statistical Validation [cite: 166, 181]
    mean_eff = results_df['efficiency'].mean()
    mean_peak = results_df['peak_load'].mean()
    reliability = (len(results_df[results_df['peak_load'] < L_MAX]) / NUM_EXPERIMENTS) * 100
    
    print("\n" + "="*45)
    print("      DIG FRAMEWORK STATISTICAL AUDIT")
    print("="*45)
    print(f"Mean Communication Reduction: {mean_eff:.2f}%")
    print(f"Mean Peak Ergonomic Load:    {mean_peak:.4f}")
    print(f"Reliability (xi < L_MAX):    {reliability:.1f}%")
    print("="*45)

    # Visualization for Paper (Figure 2 / Figure 5) [cite: 167, 205]
    plt.figure(figsize=(10,5))
    plt.hist(results_df['efficiency'], bins=25, color='#2c3e50', edgecolor='white', alpha=0.9)
    plt.axvline(mean_eff, color='#e74c3c', linestyle='--', label=f'Mean: {mean_eff:.2f}%')
    plt.title('Update Efficiency Distribution (N=1000 Monte Carlo Runs)')
    plt.xlabel('Reduction in Control Updates (%)')
    plt.ylabel('Frequency')
    plt.legend()
    plt.grid(axis='y', alpha=0.3)
    plt.savefig('experiment_results/Monte_Carlo_Final_Audit.png')
    plt.show()

    print("\nSuccess: Simulation results and distribution plots saved in 'experiment_results/'.")
    
